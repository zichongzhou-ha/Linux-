##  进程
1. 进程的描述：
    - 从磁盘中加载到内存的代码和数据，内存会对应生成PCB(进程控制块)，在linux下叫做task_struct,在该结构体中，既存储该进程的属性，也存储着代码和数据的位置及相对应的属性，也存储着下个节点的位置，以方便操作系统的管理。
    - 所以可以形象描述进程为，内核数据结构(task_struct)+代码和数据
2. 进程在调度运行的时候，进程就具有动态属性
3. 与进程有关的调用
    - getpid（）
    - getppid()(命令行上启动的话，没有意外的话，它的父进程都是bash)
    - fork():生成子进程
4. 进程的状态
    - 首先，一个cpu就会有一个运行队列，让进程进入队列，本质上就是将该进程的task_struct结构体放入队列。此时进程的状态就是运行状态(r)
    - 进程只要进入运行队列等待cpu来执行就是r状态，而不是等cpu执行到它才是运行状态
    - 不要以为进程只需要cpu资源，进程也需要外设资源
    - 但是，想较于进程来说，外设是少部分的，所以，进程需要到外设时，也需要进行排队，在这个排队等待的过程，就叫做阻塞状态。
    - 因为外设运行比较慢，等待时间就会相对过长，，这时，如果内存不够了要怎么办，对于操作系统来说，它，不是直接结束该进程，而是将进程对应的代码和数据返回到磁盘，需要时再加载过来，这时进程就在挂起状态。
    - 所谓进程的不同状态，其实也就是其实也就是在不同的队列进行等待的过程。
5. linux下是怎么样的？
    - 通过ps ajx | head -1 && ps ajx | grep "xxx"
    - R(running):直接运行代码程序就可以看到
    - S(sleeping):当你写的代码上写有printf(),这时需要调用到外设，所以查询后可看到S(printf->显示器->外设->慢->等显示器就绪，要花较长时间(cpu)99%都是等IO就绪)----------------->阻塞状态的一种
    - T(stopped):阻塞状态的一种
        1. 当使用kill -19 pid 就直接暂停了该进程，此时就是 T
        2. 然后使用kill -18 pid 就有重新启动了该进程，此时是S
        3. 出现了这样一个问题:为啥ctrl+c强制退不出呢，可以发现此时S后面没有"+",这时已经转变为了后台程序
    - D(disk sleep):深度睡眠
        1. 在该状态的进程，无法通过os杀掉，只能通过断电或进程自己醒来来解决。
        2. 这是因为当有些进程处于阻塞状态时，当此时内存严重不足，所以先把代码和数据加载到磁盘但是，这时如果直接杀死进程会导致数据丢失，因为磁盘找不到进程了，所以，操作系统给这些特殊的，存放重要数据的进程一个免死金牌，使得它们连操作系统也杀不掉，只能等待io结束
    - X(dead):死亡状态
    - Z(zomie):僵尸状态
        1. 只要子进程退出，父进程还在运行，但父进程没有读取子进程状态，子进程进入Z状态
        2.进程退出的时候，不能立即释放该进程对应的资源，保存一段时间，等待着父进程或者os来进行读取，子进程在这个等待的过程就叫僵尸状态。
        3. 不回收会导致内存泄漏的问题  
    - 孤儿进程
        1. 前面的我们发现，当我们杀死子进程的时候，其实子进程还没有彻底死亡而是处于僵尸状态，等待父进程的回收，但是，如果我们直接就杀死父进程呢，这时候就出现了孤儿进程。
        2. 当我们直接杀死父进程时，父进程就直接死亡了，我们没有看到僵尸状态，这是因为父进程被bash回收了。
        3. 虽然成为了孤儿，但也会被领养，为了以后进程的回收，被谁领养呢。显而易见，**bash**
        4. 如果是前台创建的子进程被孤儿了，就会自动变为后台进程